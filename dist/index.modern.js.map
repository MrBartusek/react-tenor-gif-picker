{"version":3,"file":"index.modern.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/component/model.tsx","../src/component/picker/search-bar.tsx","../src/component/picker/tenor-api.tsx","../src/component/picker/tenor-gif-card.tsx","../src/component/picker/tenor-gif-list.tsx","../src/component/picker/index.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import cx from 'classnames'\nimport React from 'react'\n\nexport default function Modal({\n  children,\n  className = '',\n  width = 540,\n  padding = true,\n  active = false,\n  setActive = function (_e: any) {},\n  ...props\n}: any): JSX.Element {\n  return (\n    <div\n      onClick={(_e) => {\n        if (active) {\n          setActive(false)\n        } else {\n          setActive(true)\n        }\n      }}\n      onKeyUp={(e) => {\n        if (e.key === 'Escape') {\n          setActive(false)\n        }\n      }}\n      className={cx(`Modal`, {\n        active: active\n      })}\n      {...props}\n    >\n      <Card\n        onClick={(e: any) => {\n          // stop the card being closed when we click on inner divs\n          if (active) {\n            e.stopPropagation()\n          }\n        }}\n        padding={padding}\n        className='overflow-hidden h-full'\n        style={{ maxWidth: width, width: '100%' }}\n      >\n        {children}\n      </Card>\n    </div>\n  )\n}\n\nfunction Card({\n  children,\n  padding = true,\n  style = {},\n  onClick = (_: any) => {}\n}: any): JSX.Element {\n  return (\n    <div\n      onClick={onClick}\n      style={style}\n      className={cx('Card rounded shadow bg-white mx-auto my-auto', {\n        'p-4': padding\n      })}\n    >\n      {children}\n    </div>\n  )\n}\n","import React from 'react'\n\ninterface Props {\n  query: string\n  setQuery: (query: string) => void\n  onSearch: (query: string) => void\n}\nfunction SearchBar({ setQuery, query, onSearch }: Props) {\n  const searchPhotos = async (e: any) => {\n    e.preventDefault()\n    onSearch(query)\n  }\n\n  return (\n    <div>\n      <div>\n        <form onSubmit={searchPhotos} className='flex items-center space-x-2'>\n          <input\n            className='placeholder:italic placeholder:theme-text-subtitle-1 w-full border theme-border-default rounded-md py-2 pl-3 pr-3 focus:outline-none focus:theme-border-primary focus:ring-1 sm:text-sm'\n            placeholder='Search Tenor'\n            type='text'\n            name='search'\n            value={query}\n            onChange={(e) => setQuery(e.target.value)}\n          />\n\n          <button\n            className='bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 '\n            type='submit'\n          >\n            Search\n          </button>\n        </form>\n      </div>\n    </div>\n  )\n}\n\nexport default SearchBar\n","// url Async requesting function\nfunction httpGetAsync(theUrl: any, callback: any) {\n  // create the request object\n  const xmlHttp = new XMLHttpRequest()\n\n  // set the state change callback to capture when the response comes in\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n      callback(xmlHttp.responseText)\n    }\n  }\n\n  // open as a GET call, pass in the url and set async = True\n  xmlHttp.open('GET', theUrl, true)\n\n  // call send with no params as they were passed in on the url string\n  xmlHttp.send(null)\n}\n\n// function to call the trending and category endpoints\nasync function SearchGif(\n  tenorAccessKey = '',\n  query = '',\n  page = '',\n  perPage = 30,\n  whenResult = (_e: any) => {}\n) {\n  const lmt = perPage\n\n  // test search term\n  const searchTerm = query\n\n  // using default locale of en_US\n  let searchUrl\n\n  if (!query || query.length === 0) {\n    searchUrl =\n      'https://g.tenor.com/v1/trending?key=' +\n      tenorAccessKey +\n      '&limit=' +\n      lmt +\n      '&pos=' +\n      page\n  } else {\n    searchUrl =\n      'https://g.tenor.com/v1/search?q=' +\n      searchTerm +\n      '&key=' +\n      tenorAccessKey +\n      '&limit=' +\n      lmt +\n      '&pos=' +\n      page\n  }\n\n  httpGetAsync(searchUrl, (response: any) => {\n    const json = JSON.parse(response)\n    whenResult(json)\n  })\n\n  // data will be loaded by each call's callback\n}\n\nexport default SearchGif\n","import React from 'react'\n\n/**\n * @description PhotoCard component for UnsplashImagePicker\n * @param {Object} photo - The photo to display.\n * @param {funtion} onGifSelect - Function to call when a photo is selected.\n */\nexport default function TenorGifCard({\n  photo,\n  onGifSelect = (_: any) => {}\n}: any) {\n  return (\n    <div\n      className='group relative h-60 sm:h-44 md:h-32 w-full place-items-center object-cover cursor-pointer border theme-border-default'\n      key={photo.id}\n      onClick={() => onGifSelect(photo)}\n    >\n      <img\n        className='card-img place-items-center w-full object-cover h-full rounded'\n        src={photo.media[0].tinygif.url}\n        alt={photo.content_description}\n      />\n      {/* <div\n        className=\"absolute top-0 right-0 left-0 bottom-0 invisible group-hover:visible group-hover:bg-black/20\"\n        style={{ color: \"white\" }}>\n        <div className=\"flex space-x-1 items-center place-content-center justify-between m-2\">\n          <div className=\"flex items-center space-x-1\">\n            <img\n              className=\"rounded-full h-6 w-6\"\n              src={photo.user.profile_image.small}\n              alt={photo.user.username}\n            />\n            <h6 className=\"text-xs word-breaker\">{photo.user.name}</h6>\n          </div>\n        </div>\n      </div> */}\n    </div>\n  )\n}\n","import React from 'react'\nimport TenorGifCard from './tenor-gif-card'\n// import UnsplashPhotoCard from \"./unsplash-photo-card\";\n\ninterface Props {\n  isLoading?: boolean\n  isLoadingMore?: boolean\n  photoList: Array<any>\n  total?: number | undefined\n  onGifSelect: (photo: any) => void\n  loadMore: () => void\n}\nexport default function TenorGifList({\n  isLoading = false,\n  isLoadingMore = false,\n  photoList,\n  total,\n  onGifSelect,\n  loadMore\n}: Props) {\n  const listHeight = 'calc(100vh - 125px)'\n  const ref = React.useMemo(() => React.createRef<HTMLDivElement>(), [])\n\n  const onScroll = () => {\n    if (ref.current) {\n      const { scrollTop, scrollHeight, clientHeight } = ref.current\n      if (scrollHeight - (scrollTop + clientHeight) < 20) {\n        // Contributors list lazy loading you're at the bottom of the page\n        // do this when we reach end\n        loadMore()\n      }\n    }\n  }\n  if (isLoading) {\n    return (\n      <div className='flex items-center justify-center h-96'>\n        <Loader />\n      </div>\n    )\n  }\n\n  return (\n    <div className='Body'>\n      {photoList && photoList.length > 0 && (\n        <div\n          className='TenorGifList grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 overflow-y-auto p-4'\n          style={{ maxHeight: listHeight }}\n          ref={ref}\n          onScroll={onScroll}\n        >\n          {photoList.map((photo: any) => {\n            return (\n              <TenorGifCard\n                key={photo.id}\n                photo={photo}\n                onGifSelect={onGifSelect}\n              />\n            )\n          })}\n        </div>\n      )}\n\n      {Array.isArray(photoList) && photoList.length === 0 && total === 0 && (\n        <div className='flex items-center justify-center h-96'>\n          No photos found\n        </div>\n      )}\n\n      {isLoadingMore && (\n        <div className='my-4 flex justify-center'>\n          <Loader />\n        </div>\n      )}\n    </div>\n  )\n}\nexport function Loader() {\n  return (\n    <svg\n      className='animate-spin -ml-1 mr-3 h-5 w-5 text-blue'\n      xmlns='http://www.w3.org/2000/svg'\n      fill='none'\n      viewBox='0 0 24 24'\n    >\n      <circle\n        className='opacity-25'\n        cx='12'\n        cy='12'\n        r='10'\n        stroke='currentColor'\n        strokeWidth='4'\n      />\n      <path\n        className='opacity-75'\n        fill='currentColor'\n        d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'\n      />\n    </svg>\n  )\n}\n","import React from 'react'\nimport Modal from '../model'\nimport SearchBar from './search-bar'\n\nimport SearchGif from './tenor-api'\nimport TenorGifList from './tenor-gif-list'\ninterface Props {\n  active?: boolean\n  tenorAccessKey: string\n  initialSearchQuery: string\n  setActive?: (active: boolean) => void\n  onGifSelect?: (photo: any) => void\n}\n\n/**\n * @description TenorGifPicker is a component that allows you to search for gifs from tenor.com\n * @param {string} initialSearchQuery - The initial search query.\n * @param {string} tenorAccessKey - The tenor access key.\n * @param {boolean} active - Whether the GIF picker is active.\n * @param {function} setActive - Function to set the GIF picker active.\n * @param {function} onGifSelect - Function to call when a GIF is selected.\n */\nexport default function TenorGifPicker({\n  active = false,\n  initialSearchQuery = '',\n  tenorAccessKey,\n  setActive = (_: boolean) => {},\n  onGifSelect = (_: any) => {}\n}: Props) {\n  if (!active) {\n    return null\n  }\n\n  const [pics, setPics] = React.useState<any[]>([])\n  const [total, setTotal] = React.useState<number | undefined>()\n  const [hasMore, setHasMore] = React.useState<boolean>(true)\n  const [query, setQuery] = React.useState('')\n  const [isLoading, setIsLoading] = React.useState(false)\n  const [isLoadingMore, setIsLoadingMore] = React.useState(false)\n  const [page, setPage] = React.useState('')\n  // const [convertingToBlob, setConvertingToBlob] = React.useState(false)\n\n  React.useEffect(() => {\n    setQuery(initialSearchQuery)\n    fetchGif('', initialSearchQuery)\n  }, [initialSearchQuery])\n\n  const fetchGif = (page: string, text: string, reset = false) => {\n    if (isLoading || isLoadingMore || !hasMore) {\n      return\n    }\n    if (page === '') {\n      setIsLoading(true)\n    } else {\n      setIsLoadingMore(true)\n    }\n    SearchGif(tenorAccessKey, text, page, 30, (response) => {\n      //   setPics(result.results);\n      const newPics = response.results\n      setPage(response.next)\n      if (response.next === '0' || response.results.length === 0) {\n        setHasMore(false)\n      } else if (newPics) {\n        let mergedPics = newPics\n        if (!reset) {\n          mergedPics = [...pics, ...newPics]\n        }\n        setPics(mergedPics)\n        setTotal(newPics.length)\n        setHasMore(true)\n      }\n      setIsLoadingMore(false)\n      setIsLoading(false)\n    })\n  }\n\n  return (\n    <div className='TenorGifPicker'>\n      <Modal\n        active={active}\n        setActive={setActive}\n        width='640px'\n        padding={false}\n        className='theme-bg-surface'\n      >\n        <div className='h-full' style={{ maxHeight: 'inherit' }}>\n          <div className='px-4 pt-4 font-bold text-lg theme-bg-surface'>\n            {' '}\n            Search Gif\n          </div>\n          <div className='shadow p-4 theme-bg-surface'>\n            <div className=''>\n              <SearchBar\n                onSearch={(query: string) => {\n                  setPics([])\n                  setHasMore(true)\n                  fetchGif('', query, true)\n                }}\n                query={query}\n                setQuery={setQuery}\n              />\n            </div>\n          </div>\n\n          <TenorGifList\n            total={total}\n            photoList={pics}\n            isLoading={isLoading}\n            isLoadingMore={isLoadingMore}\n            loadMore={() => {\n              fetchGif(page + 1, query)\n            }}\n            onGifSelect={async (gif: any) => {\n              try {\n                // setConvertingToBlob(true)\n                const blob = await fetch(gif.media[0].tinygif.url).then((r) =>\n                  r.blob()\n                )\n                // let image = await URL.createObjectURL(blob);\n                // setConvertingToBlob(false)\n                onGifSelect({\n                  ...gif,\n                  blobData: blob\n                })\n              } catch (error) {\n                console.log(error)\n                // setConvertingToBlob(false)\n              }\n            }}\n          />\n        </div>\n        {/* {isLoading ||\n          (convertingToBlob && (\n            <div className='absolute top-0 bottom-0 left-0 right-0'>\n              <div className='flex items-center place-content-center h-full bg-slate-600/70 '>\n                <div className='opacity-100'>\n                  <Loader />\n                </div>\n              </div>\n            </div>\n          ))} */}\n      </Modal>\n    </div>\n  )\n}\n"],"names":["Modal","children","width","padding","active","setActive","_e","props","React","onClick","onKeyUp","e","key","className","cx","Card","stopPropagation","style","maxWidth","_","SearchBar","setQuery","query","onSearch","searchPhotos","preventDefault","onSubmit","placeholder","type","name","value","onChange","target","httpGetAsync","theUrl","callback","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","open","send","SearchGif","tenorAccessKey","page","perPage","whenResult","lmt","searchTerm","searchUrl","length","response","json","JSON","parse","TenorGifCard","photo","onGifSelect","id","src","media","tinygif","url","alt","content_description","TenorGifList","isLoading","isLoadingMore","photoList","total","loadMore","listHeight","ref","useMemo","createRef","onScroll","current","scrollTop","scrollHeight","clientHeight","Loader","maxHeight","map","Array","isArray","xmlns","fill","viewBox","cy","r","stroke","strokeWidth","d","TenorGifPicker","initialSearchQuery","useState","pics","setPics","setTotal","hasMore","setHasMore","setIsLoading","setIsLoadingMore","setPage","useEffect","fetchGif","text","reset","newPics","results","next","mergedPics","gif","fetch","then","blob","blobData","error","console","log"],"mappings":"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"}