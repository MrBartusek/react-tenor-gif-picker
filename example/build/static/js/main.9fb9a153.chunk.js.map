{"version":3,"sources":["component/photo.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../../src/component/model.tsx","../../src/component/picker/search-bar.tsx","../../src/component/picker/tenor-api.tsx","../../src/component/picker/tenor-gif-card.tsx","../../src/component/picker/tenor-gif-list.tsx","../../src/component/picker/index.tsx","App.tsx","index.tsx"],"names":["Photo","photo","className","src","media","tinygif","url","alt","content_description","Symbol","iterator","asyncIterator","Modal","children","width","_ref$width","padding","_ref$padding","active","_ref$active","setActive","_e","_ref$setActive","props","React","onClick","onKeyUp","e","key","cx","Card","stopPropagation","style","maxWidth","_ref2$padding","_ref2$style","_","_ref2$onClick","SearchBar","setQuery","query","onSearch","onSubmit","preventDefault","placeholder","type","name","value","onChange","target","SearchGif","tenorAccessKey","page","perPage","whenResult","lmt","searchTerm","theUrl","callback","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","open","send","httpGetAsync","length","response","json","JSON","parse","TenorGifCard","onGifSelect","_ref$onGifSelect","id","TenorGifList","isLoading","_ref$isLoading","isLoadingMore","_ref$isLoadingMore","photoList","total","loadMore","ref","useMemo","createRef","Loader","maxHeight","onScroll","current","scrollTop","scrollHeight","clientHeight","map","Array","isArray","xmlns","fill","viewBox","cy","r","stroke","strokeWidth","d","TenorGifPicker","initialSearchQuery","_ref$initialSearchQue","useState","pics","setPics","setTotal","hasMore","setHasMore","setIsLoading","setIsLoadingMore","setPage","useEffect","fetchGif","text","reset","newPics","results","next","mergedPics","gif","body","recover","result","then","fetch","blob","blobData","error","console","log","App","photos","setActivePhotos","photosGroup","i","push","slice","process","list","group","index","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9fb9a153.chunk.js","sourcesContent":["import React from 'react'\n\nexport default function Photo({ photo }: any) {\n  return (\n    <img\n      className='image-item place-items-center w-full object-cover  rounded'\n      src={photo.media[0].tinygif.url}\n      alt={photo.content_description}\n    />\n  )\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import cx from 'classnames'\nimport React from 'react'\n\nexport default function Modal({\n  children,\n  className = '',\n  width = 540,\n  padding = true,\n  active = false,\n  setActive = function (_e: any) {},\n  ...props\n}: any): JSX.Element {\n  return (\n    <div\n      onClick={(_e) => {\n        if (active) {\n          setActive(false)\n        } else {\n          setActive(true)\n        }\n      }}\n      onKeyUp={(e) => {\n        if (e.key === 'Escape') {\n          setActive(false)\n        }\n      }}\n      className={cx(`Modal`, {\n        active: active\n      })}\n      {...props}\n    >\n      <Card\n        onClick={(e: any) => {\n          // stop the card being closed when we click on inner divs\n          if (active) {\n            e.stopPropagation()\n          }\n        }}\n        padding={padding}\n        className='overflow-hidden h-full'\n        style={{ maxWidth: width, width: '100%' }}\n      >\n        {children}\n      </Card>\n    </div>\n  )\n}\n\nfunction Card({\n  children,\n  padding = true,\n  style = {},\n  onClick = (_: any) => {}\n}: any): JSX.Element {\n  return (\n    <div\n      onClick={onClick}\n      style={style}\n      className={cx('Card rounded shadow bg-white mx-auto my-auto', {\n        'p-4': padding\n      })}\n    >\n      {children}\n    </div>\n  )\n}\n","import React from 'react'\n\ninterface Props {\n  query: string\n  setQuery: (query: string) => void\n  onSearch: (query: string) => void\n}\nfunction SearchBar({ setQuery, query, onSearch }: Props) {\n  const searchPhotos = async (e: any) => {\n    e.preventDefault()\n    onSearch(query)\n  }\n\n  return (\n    <div>\n      <div>\n        <form onSubmit={searchPhotos} className='flex items-center space-x-2'>\n          <input\n            className='placeholder:italic placeholder:theme-text-subtitle-1 w-full border theme-border-default rounded-md py-2 pl-3 pr-3 focus:outline-none focus:theme-border-primary focus:ring-1 sm:text-sm'\n            placeholder='Search Tenor'\n            type='text'\n            name='search'\n            value={query}\n            onChange={(e) => setQuery(e.target.value)}\n          />\n\n          <button\n            className='bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 '\n            type='submit'\n          >\n            Search\n          </button>\n        </form>\n      </div>\n    </div>\n  )\n}\n\nexport default SearchBar\n","// url Async requesting function\nfunction httpGetAsync(theUrl: any, callback: any) {\n  // create the request object\n  const xmlHttp = new XMLHttpRequest()\n\n  // set the state change callback to capture when the response comes in\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n      callback(xmlHttp.responseText)\n    }\n  }\n\n  // open as a GET call, pass in the url and set async = True\n  xmlHttp.open('GET', theUrl, true)\n\n  // call send with no params as they were passed in on the url string\n  xmlHttp.send(null)\n}\n\n// function to call the trending and category endpoints\nasync function SearchGif(\n  tenorAccessKey = '',\n  query = '',\n  page = '',\n  perPage = 30,\n  whenResult = (_e: any) => {}\n) {\n  const lmt = perPage\n\n  // test search term\n  const searchTerm = query\n\n  // using default locale of en_US\n  let searchUrl\n\n  if (!query || query.length === 0) {\n    searchUrl =\n      'https://g.tenor.com/v1/trending?key=' +\n      tenorAccessKey +\n      '&limit=' +\n      lmt +\n      '&pos=' +\n      page\n  } else {\n    searchUrl =\n      'https://g.tenor.com/v1/search?q=' +\n      searchTerm +\n      '&key=' +\n      tenorAccessKey +\n      '&limit=' +\n      lmt +\n      '&pos=' +\n      page\n  }\n\n  httpGetAsync(searchUrl, (response: any) => {\n    const json = JSON.parse(response)\n    whenResult(json)\n  })\n\n  // data will be loaded by each call's callback\n}\n\nexport default SearchGif\n","import React from 'react'\n\n/**\n * @description PhotoCard component for UnsplashImagePicker\n * @param {Object} photo - The photo to display.\n * @param {funtion} onGifSelect - Function to call when a photo is selected.\n */\nexport default function TenorGifCard({\n  photo,\n  onGifSelect = (_: any) => {}\n}: any) {\n  return (\n    <div\n      className='group relative h-60 sm:h-44 md:h-32 w-full place-items-center object-cover cursor-pointer border theme-border-default'\n      key={photo.id}\n      onClick={() => onGifSelect(photo)}\n    >\n      <img\n        className='card-img place-items-center w-full object-cover h-full rounded'\n        src={photo.media[0].tinygif.url}\n        alt={photo.content_description}\n      />\n      {/* <div\n        className=\"absolute top-0 right-0 left-0 bottom-0 invisible group-hover:visible group-hover:bg-black/20\"\n        style={{ color: \"white\" }}>\n        <div className=\"flex space-x-1 items-center place-content-center justify-between m-2\">\n          <div className=\"flex items-center space-x-1\">\n            <img\n              className=\"rounded-full h-6 w-6\"\n              src={photo.user.profile_image.small}\n              alt={photo.user.username}\n            />\n            <h6 className=\"text-xs word-breaker\">{photo.user.name}</h6>\n          </div>\n        </div>\n      </div> */}\n    </div>\n  )\n}\n","import React from 'react'\nimport TenorGifCard from './tenor-gif-card'\n// import UnsplashPhotoCard from \"./unsplash-photo-card\";\n\ninterface Props {\n  isLoading?: boolean\n  isLoadingMore?: boolean\n  photoList: Array<any>\n  total?: number | undefined\n  onGifSelect: (photo: any) => void\n  loadMore: () => void\n}\nexport default function TenorGifList({\n  isLoading = false,\n  isLoadingMore = false,\n  photoList,\n  total,\n  onGifSelect,\n  loadMore\n}: Props) {\n  const listHeight = 'calc(100vh - 125px)'\n  const ref = React.useMemo(() => React.createRef<HTMLDivElement>(), [])\n\n  const onScroll = () => {\n    if (ref.current) {\n      const { scrollTop, scrollHeight, clientHeight } = ref.current\n      if (scrollHeight - (scrollTop + clientHeight) < 20) {\n        // Contributors list lazy loading you're at the bottom of the page\n        // do this when we reach end\n        loadMore()\n      }\n    }\n  }\n  if (isLoading) {\n    return (\n      <div className='flex items-center justify-center h-96'>\n        <Loader />\n      </div>\n    )\n  }\n\n  return (\n    <div className='Body'>\n      {photoList && photoList.length > 0 && (\n        <div\n          className='TenorGifList grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 overflow-y-auto p-4'\n          style={{ maxHeight: listHeight }}\n          ref={ref}\n          onScroll={onScroll}\n        >\n          {photoList.map((photo: any) => {\n            return (\n              <TenorGifCard\n                key={photo.id}\n                photo={photo}\n                onGifSelect={onGifSelect}\n              />\n            )\n          })}\n        </div>\n      )}\n\n      {Array.isArray(photoList) && photoList.length === 0 && total === 0 && (\n        <div className='flex items-center justify-center h-96'>\n          No photos found\n        </div>\n      )}\n\n      {isLoadingMore && (\n        <div className='my-4 flex justify-center'>\n          <Loader />\n        </div>\n      )}\n    </div>\n  )\n}\nexport function Loader() {\n  return (\n    <svg\n      className='animate-spin -ml-1 mr-3 h-5 w-5 text-blue'\n      xmlns='http://www.w3.org/2000/svg'\n      fill='none'\n      viewBox='0 0 24 24'\n    >\n      <circle\n        className='opacity-25'\n        cx='12'\n        cy='12'\n        r='10'\n        stroke='currentColor'\n        strokeWidth='4'\n      />\n      <path\n        className='opacity-75'\n        fill='currentColor'\n        d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z'\n      />\n    </svg>\n  )\n}\n","import React from 'react'\nimport Modal from '../model'\nimport SearchBar from './search-bar'\n\nimport SearchGif from './tenor-api'\nimport TenorGifList from './tenor-gif-list'\ninterface Props {\n  active?: boolean\n  tenorAccessKey: string\n  initialSearchQuery: string\n  setActive?: (active: boolean) => void\n  onGifSelect?: (photo: any) => void\n}\n\n/**\n * @description TenorGifPicker is a component that allows you to search for gifs from tenor.com\n * @param {string} initialSearchQuery - The initial search query.\n * @param {string} tenorAccessKey - The tenor access key.\n * @param {boolean} active - Whether the GIF picker is active.\n * @param {function} setActive - Function to set the GIF picker active.\n * @param {function} onGifSelect - Function to call when a GIF is selected.\n */\nexport default function TenorGifPicker({\n  active = false,\n  initialSearchQuery = '',\n  tenorAccessKey,\n  setActive = (_: boolean) => {},\n  onGifSelect = (_: any) => {}\n}: Props) {\n  if (!active) {\n    return null\n  }\n\n  const [pics, setPics] = React.useState<any[]>([])\n  const [total, setTotal] = React.useState<number | undefined>()\n  const [hasMore, setHasMore] = React.useState<boolean>(true)\n  const [query, setQuery] = React.useState('')\n  const [isLoading, setIsLoading] = React.useState(false)\n  const [isLoadingMore, setIsLoadingMore] = React.useState(false)\n  const [page, setPage] = React.useState('')\n  // const [convertingToBlob, setConvertingToBlob] = React.useState(false)\n\n  React.useEffect(() => {\n    setQuery(initialSearchQuery)\n    fetchGif('', initialSearchQuery)\n  }, [initialSearchQuery])\n\n  const fetchGif = (page: string, text: string, reset = false) => {\n    if (isLoading || isLoadingMore || !hasMore) {\n      return\n    }\n    if (page === '') {\n      setIsLoading(true)\n    } else {\n      setIsLoadingMore(true)\n    }\n    SearchGif(tenorAccessKey, text, page, 30, (response) => {\n      //   setPics(result.results);\n      const newPics = response.results\n      setPage(response.next)\n      if (response.next === '0' || response.results.length === 0) {\n        setHasMore(false)\n      } else if (newPics) {\n        let mergedPics = newPics\n        if (!reset) {\n          mergedPics = [...pics, ...newPics]\n        }\n        setPics(mergedPics)\n        setTotal(newPics.length)\n        setHasMore(true)\n      }\n      setIsLoadingMore(false)\n      setIsLoading(false)\n    })\n  }\n\n  return (\n    <div className='TenorGifPicker'>\n      <Modal\n        active={active}\n        setActive={setActive}\n        width='640px'\n        padding={false}\n        className='theme-bg-surface'\n      >\n        <div className='h-full' style={{ maxHeight: 'inherit' }}>\n          <div className='px-4 pt-4 font-bold text-lg theme-bg-surface'>\n            {' '}\n            Search Gif\n          </div>\n          <div className='shadow p-4 theme-bg-surface'>\n            <div className=''>\n              <SearchBar\n                onSearch={(query: string) => {\n                  setPics([])\n                  setHasMore(true)\n                  fetchGif('', query, true)\n                }}\n                query={query}\n                setQuery={setQuery}\n              />\n            </div>\n          </div>\n\n          <TenorGifList\n            total={total}\n            photoList={pics}\n            isLoading={isLoading}\n            isLoadingMore={isLoadingMore}\n            loadMore={() => {\n              fetchGif(page + 1, query)\n            }}\n            onGifSelect={async (gif: any) => {\n              try {\n                // setConvertingToBlob(true)\n                const blob = await fetch(gif.media[0].tinygif.url).then((r) =>\n                  r.blob()\n                )\n                // let image = await URL.createObjectURL(blob);\n                // setConvertingToBlob(false)\n                onGifSelect({\n                  ...gif,\n                  blobData: blob\n                })\n              } catch (error) {\n                console.log(error)\n                // setConvertingToBlob(false)\n              }\n            }}\n          />\n        </div>\n        {/* {isLoading ||\n          (convertingToBlob && (\n            <div className='absolute top-0 bottom-0 left-0 right-0'>\n              <div className='flex items-center place-content-center h-full bg-slate-600/70 '>\n                <div className='opacity-100'>\n                  <Loader />\n                </div>\n              </div>\n            </div>\n          ))} */}\n      </Modal>\n    </div>\n  )\n}\n","import React from 'react'\n\nimport 'react-tenor-gif-picker/dist/index.css'\nimport Photo from './component/photo'\nimport TenorGifPicker from 'react-tenor-gif-picker'\n\nconst App = () => {\n  const [active, setActive] = React.useState(false)\n  const [photos, setActivePhotos] = React.useState<any[]>([])\n  const tenorKey = process.env.REACT_APP_TENOR_KEY\n\n  /// Make group of photos for 3 columns\n  const photosGroup = () => {\n    const photosGroup = []\n    for (let i = 0; i < photos.length; i += 3) {\n      photosGroup.push(photos.slice(i, i + 3))\n    }\n    return photosGroup\n  }\n\n  return (\n    <div className='App container bg-gray-50'>\n      <button\n        className='SearchButton bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded'\n        onClick={() => {\n          setActive(true)\n        }}\n      >\n        Search Gif\n      </button>\n      <TenorGifPicker\n        tenorAccessKey={tenorKey ?? ''}\n        active={active}\n        setActive={setActive}\n        initialSearchQuery=''\n        onGifSelect={(photo: any) => {\n          let list = (photos ?? []) as any[]\n          list.push(photo)\n          setActivePhotos(list)\n          setActive(false)\n          console.log(photo)\n        }}\n      />\n      <div className='image-gallery'>\n        {photosGroup().length > 0 &&\n          photosGroup().map((group: any, index) => (\n            <div key={index} className={'column'}>\n              {group.map((photo: any) => (\n                <Photo key={photo.id} photo={photo} />\n              ))}\n            </div>\n          ))}\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}